---
title: 0001. 两数之和
slug: two-sum
---

# [0001. 两数之和](https://leetcode.cn/problems/two-sum/)

## 题目说明

**描述**：给定一个整数数组 `nums` 和一个整数目标值 `target`。

**要求**：在该数组中找出和为 `target` 的两个整数，并输出这两个整数的下标。可以按任意顺序返回答案。

**说明**：

- $2 \le nums.length \le 10^4$。
- $-10^9 \le nums[i] \le 10^9$。
- $-10^9 \le target \le 10^9$。
- 只会存在一个有效答案。

**示例**：

- 示例 1：

```text 
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

- 示例 2：

```text
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

## 我的思路

1. 首先可以肯定一点：寻找整数数组`nums`中的某个或者某几个元素，必然需要通过下标，进行数组的遍历操作。

2. 假设这个数组中有两个元素的下标分别是`i`和`j`，正好满足`nums[i] + nums[j] == target `，那么我就可以说，`i`和`j`就是要寻找的答案。

3. 为了找到索引`i`和`j`，需要进行如下遍历：

   1. 假设遍历的索引为`i`，它需要从索引0开始，一直遍历到数组的最后一个元素，即`nums[nums.length - 1]`；
   2. 在第一次遍历过程中，每一次确定索引`i`的位置，都需要将索引`i`后面的元素分别与其相加，并判断是否等于target；

   ```java
   for(int i=0;i<nums.length-1;i++){
       for(int j=i+1;j<nums.length;j++){
           if(nums[i] + nums[j] == target){
               //i和j即为所求
           }
       }
   }
   ```

4. 全量的代码如下：

   ```java
   public int[] twoSum(int[] nums, int target) {
       for(int i=0;i<nums.length-1;i++){
           for(int j=i+1;j<nums.length;j++){
               if(nums[i] + nums[j] == target){
                   return new int[]{i,j};
               }
           }
       }
       return null;
   }
   ```

   当然，这属于一种暴力破解的方式。其核心逻辑在于，对数组中的元素进行数学逻辑上的**组合**，以穷尽遍历的方式找到符合要求的数据。
   
   其中，用到的变量只有固定的`i`和`j`，所以空间复杂度为：$O(1)$。
   
   由于采用的是循环嵌套循环的方式，所以时间复杂度为：$O(n^2)$。

## 空间换时间

对于上面比较暴力的方式而言，由于是`for`循环嵌套`for`循环的方式，故而时间复杂度不太理想。于是产生了下面的想法：

1. 将内部`for`循环拆解出来